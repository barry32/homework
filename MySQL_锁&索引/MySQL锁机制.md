#### MySQL锁机制

1. 按照锁的粒度，锁的功能来分析

* 分为全局锁、表级锁、行级锁
  * 表级读锁：
    * 表的读锁互斥表写锁，允许其他会话对当前表加读锁。
    * 当前session不能查询其他未锁定的表
  * 表级写锁：
    * 当前session 添加表级别写锁，其他session不能添加当前表级别读锁和表写锁。
  * 元数据锁：
    * DML自动添加元数据读锁、DDL自动添加元数据写锁。两者冲突。故而在正常的生产环境中都是晚上用户访问少的时候执行DDL。
  * 行级锁：
    * 记录锁：聚簇索引和唯一键锁索引在RC和RR隔离级别下不需要添加间隙锁。而在RR隔离级别下，非唯一键索引记录锁会锁住当前索引间隙锁和记录锁，以及对应主键的记录锁。用来防止幻读的可能。
    * 间隙锁：e.g: select * from table_name where id >1 and id< 5 for update；（id为主键）此时会触发间隙锁如果且锁区间是 前开后闭。
    * 临键锁 = 记录锁 + 间隙锁
    * 插入意向锁：每条插入语句都是默认添加插入意向锁。同一个间隙的不同主键ID插入语句之间不会冲突。如果第二个事务执行插入第一个事务的主键ID，则会阻塞。当前是因为拿不到间隙写锁。
    * 表意向锁： 当执行插入等修改语句自动添加表意向写锁，用来标志当前表中是否行锁，从而提高效率。
    * select * from table_name where id =1 lock in share mode;触发表意向读锁。单纯的select语句不触发。

2. 什么是死锁，为什么会发生，如何排查？

   两个session以上的锁使用事务，出现加锁顺序不一致的场景。可以使用

   show engine innodb status; 查看死锁。

3. 行锁是通过加在什么上完成的锁定？

   在RC和RR隔离级别下：

   主键索引精确匹配，加锁 存在记录，使用记录锁，不存在记录，锁住等值的间隙。

   唯一键索引精确匹配，锁住当前记录锁和聚簇索引记录锁。不存在记录则锁住当前索引的等值的间隙锁。

   非唯一键在RC精确匹配下和唯一键索引相同。

   非唯一键在RR精确匹配，因为需要杜绝幻读的缘故，所以需要在当前索引上再加间隙锁。
   
4. 详细说说这条 SQL 的锁定情况：`delete from tt where uid = 666`;
   

都会加表意向锁写锁

* uid如果是主键且事务隔离级别为RC
  

加行记录锁 

   * uid如果是唯一键且事务隔离级别为RC

   加行记录锁、聚簇索引加行记录锁，

   * uid如果是非唯一键且事务隔离级别为RC
   
     加行记录锁、聚簇索引加行记录锁
   
   * 没有索引
   
     先加全局的行锁，之后不满足条件的记录再解锁。
   
   * uid如果是主键且事务隔离级别为RR
   
     加行记录锁 

* uid如果是唯一键且事务隔离级别为RR

    加行记录锁、聚簇索引加行记录锁，

* uid如果是非唯一键且事务隔离级别为RR

  当前索引加行记录锁、再加间隙锁解决幻读问题、聚簇索引加行记录锁
  
* 没有索引

    先加全局的行锁，之后不满足条件的记录再解锁。

5. 请你说一说MySQL的SQL优化

   * 优先主要考虑分库和分表的问题，将按照门店和大区分表，将大区中品名、保质期等活跃字段和非活跃字段分表保存，将图文表单独保存。

   * 对于重要的字段，建立缓存的前置表。当业务表更新之后，通过消息异动的方式更新到这些表。减少对外的接口查询表的次数。
   * 对于业务操作禁止使用表的join。
   * 优先使用考虑等值查询，建立组合索引的优先级：A字段区分度低但场景中为等值查询，B字段区分度高但场景中多为范围查询，则按A，B建立组合索引。同为等值查询的情况下，区分度高的字段在组合索引中越靠前。
   * 禁止使用子查询
   * 尽量使用索引字段排序，如果当前查询使用二级索引，也可以使用主键索引排序。因为回表查询聚簇索引时，数据是有序的。
   * 禁止使用非索引字段排序，导致多次寻址，且最后在内存中排序。
   * 对于区分度很低的数据可能不走索引，如果数据是很少变动的如：税率表等，可以使用本地缓存。
   * 尽量查询少的字段，使用索引覆盖

   * 遵守最左前缀原则
   * 不要在索引列上使用not in 等语句，非索引列上可以使用，因为这些是在SQL Layer中进行筛选。

